<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOST CHAIN v3.1</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        body { background: #050505; color: #00ff41; font-family: 'Courier New', monospace; padding: 15px; display: flex; flex-direction: column; align-items: center; }
        .header-container { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 600px; justify-content: space-between; }
        h1 { font-size: 1.8rem; text-shadow: 0 0 10px #00ff41; margin: 0; }
        .ghost-ascii { white-space: pre; font-size: 10px; line-height: 10px; color: #00ff41; text-shadow: 0 0 5px #00ff41; }
        #log { border: 1px solid #00ff41; width: 100%; max-width: 600px; height: 50vh; overflow-y: auto; padding: 15px; background: #000; margin-bottom: 20px; box-shadow: 0 0 15px #00ff4133; font-size: 16px; box-sizing: border-box; display: block; }
        .block { border-left: 3px solid #00ff41; margin: 12px 0; padding: 12px; background: #0a0a0a; animation: fadein 0.5s; word-wrap: break-word; }
        .sender-id { color: #888; font-size: 0.7em; margin-bottom: 4px; display: block; }
        @keyframes fadein { from { opacity: 0; } to { opacity: 1; } }
        .input-group { display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 600px; margin-bottom: 15px; }
        input { background: #000; color: #00ff41; border: 1px solid #00ff41; padding: 15px; font-size: 18px; outline: none; border-radius: 4px; width: 100%; box-sizing: border-box; }
        button { background: #00ff41; color: #000; border: none; padding: 18px; cursor: pointer; font-weight: bold; font-size: 18px; border-radius: 4px; transition: 0.2s; width: 100%; }
        button:active { background: #008f25; }
        .btn-small { padding: 8px 12px; font-size: 12px; background: transparent; color: #00ff41; border: 1px solid #00ff41; width: auto; }
        .system { color: #888; font-size: 0.9em; margin-bottom: 10px; text-align: center; }
        .hidden { display: none; }
        #debug-box { width: 100%; max-width: 600px; background: #111; border: 1px solid #333; padding: 12px; margin-top: 15px; font-size: 14px; color: #ffa500; border-radius: 4px; box-sizing: border-box; }
        #debug-text { max-height: 100px; overflow-y: auto; }
        #docs-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.98); z-index: 100; overflow-y: auto; padding: 30px; box-sizing: border-box; border: 2px solid #00ff41; display:none; }
        .docs-content { max-width: 800px; margin: 0 auto; line-height: 1.6; color: #00ff41; }
        hr { border: 0; border-top: 1px dashed #00ff41; margin: 20px 0; }
        @media (max-width: 600px) { h1 { font-size: 1.4rem; } #log { height: 40vh; } }
    </style>
</head>
<body>

    <div class="header-container">
        <div>
            <h1>GHOST_CHAIN</h1>
            <button class="btn-small" onclick="toggleDocs(true)">VIEW_DOCS</button>
        </div>
        <div class="ghost-ascii"> .-. |oo | |   | '^^^' </div>
    </div>
    
    <div id="docs-overlay">
        <div class="docs-content">
            <button onclick="toggleDocs(false)" style="float:right; padding:10px; background:#00ff41; color:#000; border:none; font-weight:bold; cursor:pointer; width:auto;">CLOSE_X</button>
            <pre class="ghost-ascii" style="font-size: 14px; line-height: 14px;"> .-. |oo | < GHOST_CHAIN_v3_ACTIVE | | '^^^' </pre>
            <h2>GHOST CHAIN: A Technical White Paper (v3)</h2>
            <p><strong>1. Abstract:</strong> Ghost Chain is an ephemeral Peer-to-Peer (P2P) protocol utilizing a decentralized "Lighthouse" discovery mechanism to establish encrypted WebRTC tunnels. It prioritizes volatile memory-only persistence.</p>
            <p><strong>2. The Signaling Layer:</strong> Ghost Chain solves NAT traversal using Nostr Ephemeral Relays as a Beacon. Nodes broadcast randomized Peer IDs to a specific Frequency Hash. This ensures zero-trace operation without needing a manual Janitor script, as signaling events are broadcast-only and never stored.</p>
            <p><strong>3. Consensus:</strong> Simplified GHOST protocol. Longest Chain Wins: Upon connection, peers perform a State Sync to adopt the longest chain. Mining refers to local block creation broadcast directly via WebRTC.</p>
            <p><strong>4. Security:</strong> Frequency coordinates derived via SHA-256. Transport uses mandatory WebRTC DTLS encryption. Application-level secrecy supports AES-GCM via the Secret Key.</p>
            <p><strong>5. Persistence:</strong> Zero-Knowledge Hosting. Storage is RAM-only. Never written to Disk, LocalStorage, or Cookies.</p>
            <hr>
            <h2>GHOST CHAIN: USER OPERATING GUIDE</h2>
            <p><strong>1. Prerequisites:</strong> Access URL and a modern browser. No PAT or registration required.</p>
            <p><strong>2. Initializing:</strong> Select a Room Name (shared frequency) and a Secret Key (encryption). Click INITIALIZE_GHOST.</p>
            <p><strong>3. Communication:</strong> Type data and click MINE. New blocks are broadcast directly into your peer's browser RAM.</p>
            <p><strong>4. The Kill Switch:</strong> Closing the tab or refreshing acting as a master purge, instantly erasing the local ledger and session identity.</p>
        </div>
    </div>

    <div id="setup" style="width: 100%; max-width: 600px;">
        <p class="system">STATUS: <span id="conn-status" style="color: yellow;">OFFLINE</span></p>
        <div class="input-group">
            <input type="text" id="room-name" placeholder="Room Name (e.g. Sector-7)">
            <input type="password" id="cipher-key" placeholder="Secret Key">
            <button onclick="boot()">INITIALIZE_GHOST</button>
        </div>
        <div id="debug-box">
            <div style="border-bottom: 1px solid #333; margin-bottom: 5px;">DIAGNOSTICS:</div>
            <div id="debug-text">> Waiting for initialization...</div>
        </div>
    </div>

    <div id="terminal" class="hidden" style="width: 100%; max-width: 600px;">
        <div id="log"></div>
        <div class="input-group">
            <input type="text" id="data-input" placeholder="Enter data to mine...">
            <button onclick="mine()">MINE</button>
        </div>
        <p id="peer-status" class="system">Searching for peers...</p>
    </div>

    <script>
        const RELAYS = ['wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.snort.social'];
        let blockchain = [];
        let peer = null;
        let connections = [];
        let roomTopic = "";
        let sockets = [];

        function toggleDocs(show) { document.getElementById('docs-overlay').style.display = show ? 'block' : 'none'; }
        function debug(msg) { const d = document.getElementById('debug-text'); d.innerHTML += `<br>> ${msg}`; d.scrollTop = d.scrollHeight; }

        async function boot() {
            const roomName = document.getElementById('room-name').value;
            const key = document.getElementById('cipher-key').value;
            if(!roomName || !key) return alert("Room and Key required.");
            
            debug("Initializing Immortal Ghost Protocol...");
            roomTopic = await hashTopic(roomName + key);

            peer = new Peer(`gc-${Math.floor(Math.random()*99999)}`);
            peer.on('open', (myId) => {
                debug(`Local Node Live: ${myId}`);
                document.getElementById('setup').classList.add('hidden');
                document.getElementById('terminal').classList.remove('hidden');
                
                RELAYS.forEach(url => {
                    const ws = new WebSocket(url);
                    ws.onopen = () => {
                        debug(`Relay Active: ${url.split('//')[1]}`);
                        sockets.push(ws);
                        announce(myId, ws);
                        listen(ws);
                    };
                });
            });
            peer.on('connection', setupConn);
        }

        async function hashTopic(str) {
            const msgBuffer = new TextEncoder().encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function announce(myId, ws) {
            if(ws.readyState !== 1) return;
            const ev = { kind: 20001, created_at: Math.floor(Date.now()/1000), tags: [['t', roomTopic]], content: myId, pubkey: '0'.repeat(64) };
            ws.send(JSON.stringify(["EVENT", ev]));
            setTimeout(() => announce(myId, ws), 10000);
        }

        function listen(ws) {
            ws.send(JSON.stringify(["REQ", "ghost-" + Math.random(), { kinds: [20001], "#t": [roomTopic] }]));
            ws.onmessage = (msg) => {
                const d = JSON.parse(msg.data);
                if (d[0] === "EVENT" && d[2].content !== peer.id && !connections.find(c => c.peer === d[2].content)) {
                    debug(`Tunneling via Mesh: ${d[2].content.slice(-5)}`);
                    setupConn(peer.connect(d[2].content));
                }
            };
        }

        function setupConn(conn) {
            conn.on('open', () => {
                connections.push(conn);
                document.getElementById('peer-status').innerText = `PEERS CONNECTED: ${connections.length}`;
                conn.send({ type: 'SYNC' });
            });
            conn.on('data', data => {
                if(data.type === 'SYNC') conn.send({ type: 'CHAIN', chain: blockchain });
                if(data.type === 'CHAIN' && data.chain.length > blockchain.length) {
                    blockchain = data.chain;
                    render();
                }
            });
        }

        function mine() {
            const val = document.getElementById('data-input').value;
            if(!val) return;
            // Ghost ID is the last 5 chars of the randomized Peer ID
            const ghostId = peer.id.slice(-5);
            blockchain.push({ 
                index: blockchain.length, 
                data: val, 
                ts: new Date().toLocaleTimeString(),
                sender: ghostId 
            });
            connections.forEach(c => c.send({ type: 'CHAIN', chain: blockchain }));
            render();
            document.getElementById('data-input').value = "";
        }

        function render() {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML = blockchain.map(b => `
                <div class="block">
                    <span class="sender-id">GHOST_${b.sender}</span>
                    <b>BLOCK_${b.index}:</b> ${b.data}
                    <div style="font-size:0.7em; color:#444;">TIME: ${b.ts}</div>
                </div>`).join('');
            logDiv.scrollTop = logDiv.scrollHeight;
        }
    </script>
</body>
</html>