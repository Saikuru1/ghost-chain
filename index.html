<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOST_CHAIN_v6.6.1_MASTER</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --glow: #00ff41; --dim: #003300; --bg: #050505; --red: #ff4141; --panel: #0a0a0a; --gold: #d4af37; }
        body { background: var(--bg); color: var(--glow); font-family: 'Courier New', monospace; padding: 20px; display: flex; flex-direction: column; align-items: center; margin: 0; }
        .ghost-ascii { white-space: pre; font-size: 14px; line-height: 1.1; color: var(--glow); text-shadow: 0 0 8px var(--glow); margin-bottom: 20px; cursor: pointer;}
        .container { width: 100%; max-width: 700px; }
        .node-panel { border: 1px solid var(--glow); padding: 15px; margin-bottom: 20px; background: #000; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .stat-box { border: 1px solid var(--dim); padding: 10px; background: var(--panel); position: relative; }
        .label { font-size: 0.7em; color: var(--dim); text-transform: uppercase; }
        .value { font-size: 1.1em; color: #fff; display: block; margin-top: 5px; cursor: pointer; word-break: break-all; }
        #log { border: 1px solid var(--glow); height: 35vh; overflow-y: auto; padding: 10px; background: #000; margin-bottom: 15px; font-size: 13px; text-align: left;}
        .block { border-left: 2px solid var(--glow); margin: 8px 0; padding: 10px; background: var(--panel); position: relative; }
        .block-meta { display: flex; justify-content: space-between; font-size: 0.7em; color: #444; margin-top: 8px; border-top: 1px solid #111; }
        input, button { background: #000; color: var(--glow); border: 1px solid var(--dim); padding: 12px; font-size: 14px; width: 100%; box-sizing: border-box; margin-bottom: 10px; outline: none; }
        button { background: var(--glow); color: #000; border: none; cursor: pointer; font-weight: bold; text-transform: uppercase; }
        .portal-area { border: 1px dashed var(--dim); padding: 20px; text-align: center; background: #000; margin-bottom: 15px; }
        .transfer-panel { border: 1px double var(--glow); padding: 15px; margin-bottom: 15px; background: #050505; }
        .btn-alt { background: #111; color: var(--glow); border: 1px solid var(--glow); font-size: 10px; margin-top: 5px; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <pre class="ghost-ascii">
    .-.     [ GHOST_CORE_v6.6.1 ]
   |oo |    [ L1_SETTLEMENT: ACTIVE ]
   |   |    [ STATUS: <span id="global-status">OFFLINE</span> ]
   '^^^'</pre>

    <div class="container">
        <div id="node-init">
            <input type="password" id="node-seed" placeholder="MASTER_IDENTITY_SEED">
            <button onclick="bootNode()">ACTIVATE_SOVEREIGN_NODE</button>
        </div>

        <div id="node-dashboard" class="hidden">
            <div class="node-panel">
                <div class="stat-box" onclick="copyMyID()">
                    <span class="label">WALLET_ADDRESS</span>
                    <span class="value" id="stat-id" style="font-size: 0.75em;">...</span>
                </div>
                <div class="stat-box">
                    <span class="label">GHC_SAVED_BALANCE</span>
                    <span class="value" id="stat-balance">0.0000</span>
                </div>
                <div class="stat-box">
                    <span class="label">Mesh_Discovery</span>
                    <span class="value" id="stat-peers">0 Peers</span>
                </div>
                <div class="stat-box">
                    <span class="label">Node_Type</span>
                    <span class="value" id="stat-role" style="color: gold;">SCANNING</span>
                </div>
            </div>

            <div id="transfer-area" class="transfer-panel">
                <span class="label">Initiate_Quorum_Transfer</span>
                <input type="text" id="target-addr" placeholder="RECIPIENT_ADDR (gh-...)">
                <input type="number" id="transfer-amount" placeholder="GHC_AMOUNT">
                <button onclick="proposeTX()">AUTHORIZE_TRANSFER</button>
            </div>

            <div id="portal-entry" class="portal-area">
                <div style="margin-bottom: 10px; font-size: 11px; color: var(--gold);">SYSTEM_PORTAL</div>
                <input type="text" id="room-id" placeholder="ROOM_ID (GHOST_SCAN for System)">
                <input type="password" id="room-key" placeholder="ENCRYPTION_KEY">
                <button onclick="joinRoom()">PHASE_IN</button>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                    <button class="btn-alt" onclick="exportUpdatedMaster()">EVOLVE_FILE</button>
                    <button class="btn-alt" onclick="autoFillGenesis()">JOIN_GHOST_CHAT</button>
                </div>
            </div>

            <div id="room-view" class="hidden">
                <div id="dev-mint-portal" class="hidden" style="border: 1px solid var(--red); padding: 15px; margin-bottom: 15px; background: #1a0000;">
                    <span class="label" style="color:var(--red)">MASTER_MINT_AUTHORITY</span>
                    <input type="number" id="mint-amt" placeholder="MINT_QUANTITY">
                    <button onclick="executeMint()" style="background:var(--red); color:white;">EXECUTE_GENESIS_MINT</button>
                </div>

                <div id="admin-tools" class="hidden" style="border: 1px solid var(--gold); padding: 10px; margin-bottom: 10px;">
                    <span class="label" style="color:var(--gold)">LIGHTHOUSE_CONSOLE</span>
                    <button onclick="triggerAudit()" style="background:var(--gold); color:black; margin-top:5px;">TRIGGER_STATE_AUDIT</button>
                </div>
                <div id="log"></div>
                <input type="text" id="msg" placeholder="Write to Chain..." onkeypress="if(event.key==='Enter') mineBlock()">
                <button id="broadcast-btn" onclick="mineBlock()">BROADCAST_MESSAGE</button>
                <button class="btn-alt" onclick="exitRoom()">EXIT_PORTAL</button>
            </div>
        </div>
    </div>

<script>
    const QUORUM_NODES = ['gh-d22be1bf2740', 'gh-35d9aaaa58ec', 'gh-78e1bc92a11f'];
    const DEV_ID = 'gh-d22be1bf2740'; // Hex for 'dev-ma' (from 'dev-master' seed)
    const THRESHOLD = 2;

    let nodePeer = null, connections = {}, ledgerDB = null, blockchain = [];
    let walletAddr = "", myBalance = 0;
    let isLighthouse = false, isDev = false, roomKey = "", roomHash = "";
    let votesReceived = {}, auditVotes = {};

    async function initDB() {
        return new Promise((resolve) => {
            const req = indexedDB.open("GhostCoreDB_v6", 3);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if(!db.objectStoreNames.contains("ledger")) db.createObjectStore("ledger", { keyPath: "hash" });
                if(!db.objectStoreNames.contains("state")) db.createObjectStore("state", { keyPath: "key" });
            };
            req.onsuccess = (e) => { ledgerDB = e.target.result; resolve(); };
        });
    }

    async function bootNode() {
        const seed = document.getElementById('node-seed').value;
        if(!seed) return alert("SEED_REQUIRED");
        await initDB();
        const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(seed));
        walletAddr = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 12);
        
        isLighthouse = QUORUM_NODES.includes(`gh-${walletAddr}`);
        isDev = (`gh-${walletAddr}` === DEV_ID || seed === "master_dev_key");

        const savedBal = await getFromDB('state', 'balance');
        myBalance = savedBal ? savedBal.value : 0.00;

        nodePeer = new Peer(`gh-${walletAddr}`, { host: '0.peerjs.com', port: 443, secure: true });
        nodePeer.on('open', (id) => {
            document.getElementById('node-init').classList.add('hidden');
            document.getElementById('node-dashboard').classList.remove('hidden');
            document.getElementById('stat-id').innerText = id;
            document.getElementById('global-status').innerText = "ONLINE";
            document.getElementById('stat-role').innerText = isDev ? "MASTER_DEVELOPER" : (isLighthouse ? "LIGHTHOUSE_CORE" : "GHOST_NODE");
            refreshUI();
            QUORUM_NODES.forEach(p => connectToPeer(p));
        });
        nodePeer.on('connection', setupEvents);
    }

    function setupEvents(conn) {
        connections[conn.peer] = conn;
        conn.on('data', async (data) => {
            if(data.type === 'TX_PROPOSAL' && isLighthouse) {
                const txHash = btoa(data.from + data.to + data.amt + data.nonce);
                broadcast('TX_VOTE', { ...data, hash: txHash, voter: nodePeer.id });
            }
            if(data.type === 'TX_VOTE') {
                if(!QUORUM_NODES.includes(data.voter)) return;
                if(!votesReceived[data.hash]) votesReceived[data.hash] = new Set();
                votesReceived[data.hash].add(data.voter);
                if(votesReceived[data.hash].size >= THRESHOLD) commitToLedger(data);
            }
            if(data.type === 'MINT_EVENT') {
                if(data.to === nodePeer.id) {
                    myBalance += data.amt;
                    saveState();
                    alert(`GENESIS_MINT_RECEIVED: +${data.amt}`);
                }
                logSystem(`GENESIS_MINT: ${data.amt} GHC -> ${data.to}`);
            }
            if(data.type === 'AUDIT_PROPOSAL') {
                if(!auditVotes[data.rootHash]) auditVotes[data.rootHash] = new Set();
                auditVotes[data.rootHash].add(data.voter);
                if(auditVotes[data.rootHash].size >= THRESHOLD) finalizeAudit(data.rootHash);
            }
            if(data.type === 'CHAIN' && data.room === roomHash) {
                if(data.chain.length > blockchain.length) { blockchain = data.chain; renderChat(); }
            }
            if(data.type === 'SYNC_REQ' && data.room === roomHash) conn.send({type: 'CHAIN', chain: blockchain, room: roomHash});
            updatePeersUI();
        });
        conn.on('close', () => { delete connections[conn.peer]; updatePeersUI(); });
    }

    async function executeMint() {
        if(!isDev) return;
        const amt = parseFloat(document.getElementById('mint-amt').value);
        const target = document.getElementById('target-addr').value || nodePeer.id;
        if(isNaN(amt)) return;
        
        broadcast('MINT_EVENT', { to: target, amt: amt });
        if(target === nodePeer.id) { myBalance += amt; saveState(); }
        logSystem(`MINT_SUCCESS: ${amt} GHC issued.`);
    }

    async function proposeTX() {
        const target = document.getElementById('target-addr').value;
        const amt = parseFloat(document.getElementById('transfer-amount').value);
        if(amt > myBalance || !target.startsWith('gh-')) return alert("INVALID_TX");
        broadcast('TX_PROPOSAL', { from: nodePeer.id, to: target, amt: amt, nonce: Date.now() });
        logSystem("TX_PROPOSED: Awaiting Quorum...");
    }

    async function commitToLedger(tx) {
        const exists = await getFromDB('ledger', tx.hash);
        if(exists) return;
        const transaction = ledgerDB.transaction(["ledger", "state"], "readwrite");
        transaction.objectStore("ledger").add({ hash: tx.hash, from: tx.from, to: tx.to, amt: tx.amt });
        if(tx.from === nodePeer.id) myBalance -= tx.amt;
        if(tx.to === nodePeer.id) { myBalance += tx.amt; alert(`GHC_RECEIVED: +${tx.amt}`); }
        transaction.objectStore("state").put({ key: 'balance', value: myBalance });
        transaction.oncomplete = () => { logSystem(`TX_SETTLED: ${tx.hash.slice(0,8)}`); refreshUI(); };
    }

    async function triggerAudit() {
        const stateHash = btoa(myBalance.toFixed(4) + Date.now());
        broadcast('AUDIT_PROPOSAL', { voter: nodePeer.id, rootHash: stateHash });
        logSystem("AUDIT_PROPOSED: Syncing Natural State...");
    }

    async function finalizeAudit(root) {
        const transaction = ledgerDB.transaction(["ledger", "state"], "readwrite");
        transaction.objectStore("ledger").clear();
        transaction.objectStore("state").put({ key: 'last_root', value: root });
        transaction.oncomplete = () => { logSystem("HISTORY_BURNED: State Verified."); };
    }

    async function joinRoom() {
        const rId = document.getElementById('room-id').value;
        roomKey = document.getElementById('room-key').value;
        if(rId === "GHOST_SCAN") {
            document.getElementById('portal-entry').classList.add('hidden');
            document.getElementById('room-view').classList.remove('hidden');
            if(isLighthouse) document.getElementById('admin-tools').classList.remove('hidden');
            if(isDev) document.getElementById('dev-mint-portal').classList.remove('hidden');
            logSystem("L1_SCAN_ACTIVE: Reading Ledger...");
            return;
        }
        if(!rId || !roomKey) return;
        const h = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(rId));
        roomHash = Array.from(new Uint8Array(h)).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 16);
        document.getElementById('portal-entry').classList.add('hidden');
        document.getElementById('room-view').classList.remove('hidden');
        Object.values(connections).forEach(c => c.send({type: 'SYNC_REQ', room: roomHash}));
    }

    async function mineBlock() {
        const msgStr = document.getElementById('msg').value; if(!msgStr) return;
        const encData = await crypt(msgStr, roomKey, 'enc');
        blockchain.push({ data: encData, sender: walletAddr.slice(-4), ts: new Date().toLocaleTimeString() });
        Object.values(connections).forEach(c => c.send({ type: 'CHAIN', chain: blockchain, room: roomHash }));
        renderChat();
        document.getElementById('msg').value = "";
    }

    function renderChat() {
        const log = document.getElementById('log'); log.innerHTML = "";
        blockchain.forEach(async b => {
            let m = "[ENCRYPTED]"; try { m = await crypt(b.data, roomKey, 'dec'); } catch(e){}
            log.innerHTML += `<div class="block">${m}<div class="block-meta"><span>GHOST_${b.sender}</span><span>${b.ts}</span></div></div>`;
            log.scrollTop = log.scrollHeight;
        });
    }

    function broadcast(type, data) {
        const pkg = { ...data, type: type };
        Object.values(connections).forEach(c => c.send(pkg));
        if(isLighthouse || isDev) handleInternalData(pkg);
    }

    function handleInternalData(data) {
        if(data.type === 'TX_VOTE') {
            if(!votesReceived[data.hash]) votesReceived[data.hash] = new Set();
            votesReceived[data.hash].add(nodePeer.id);
            if(votesReceived[data.hash].size >= THRESHOLD) commitToLedger(data);
        }
    }

    function logSystem(msg) { const log = document.getElementById('log'); log.innerHTML = `<div class="block" style="color:var(--gold)">> ${msg}</div>` + log.innerHTML; }
    function exitRoom() { document.getElementById('room-view').classList.add('hidden'); document.getElementById('portal-entry').classList.remove('hidden'); blockchain=[]; document.getElementById('dev-mint-portal').classList.add('hidden'); document.getElementById('admin-tools').classList.add('hidden'); }
    function refreshUI() { document.getElementById('stat-balance').innerText = myBalance.toFixed(4); }
    function saveState() { const tx = ledgerDB.transaction(["state"], "readwrite"); tx.objectStore("state").put({ key: 'balance', value: myBalance }); refreshUI(); }
    function updatePeersUI() { document.getElementById('stat-peers').innerText = `${Object.keys(connections).length} Peers`; }
    function connectToPeer(pid) { if(pid !== nodePeer.id && !connections[pid]) { const c = nodePeer.connect(pid); c.on('open', () => setupEvents(c)); } }
    function getFromDB(s, k) { return new Promise(r => { const req = ledgerDB.transaction([s], "readonly").objectStore(s).get(k); req.onsuccess = () => r(req.result); }); }
    async function crypt(t, k, m) { const enc = new TextEncoder(); const kh = await crypto.subtle.digest('SHA-256', enc.encode(k)); const ck = await crypto.subtle.importKey('raw', kh, 'AES-GCM', false, ['encrypt', 'decrypt']); if(m === 'enc') { const iv = crypto.getRandomValues(new Uint8Array(12)); const c = await crypto.subtle.encrypt({name: 'AES-GCM', iv}, ck, enc.encode(t)); return { c: Array.from(new Uint8Array(c)), i: Array.from(iv) }; } else { const d = await crypto.subtle.decrypt({name: 'AES-GCM', iv: new Uint8Array(t.i)}, ck, new Uint8Array(t.c)); return new TextDecoder().decode(d); } }
    function autoFillGenesis() { document.getElementById('room-id').value = "ALL_GHOSTS"; document.getElementById('room-key').value = "GENESIS_DEACON"; joinRoom(); }
    function copyMyID() { navigator.clipboard.writeText(nodePeer.id); alert("ID_COPIED"); }
    function exportUpdatedMaster() { const blob = new Blob([document.documentElement.outerHTML], {type: 'text/html'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `ghost_v6.6.1.html`; a.click(); }
</script>
</body>
</html>